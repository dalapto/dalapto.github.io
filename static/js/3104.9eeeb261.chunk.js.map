{"version":3,"file":"static/js/3104.9eeeb261.chunk.js","mappings":"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","sources":["../node_modules/@esri/calcite-components/dist/components/form.js","../node_modules/@esri/calcite-components/dist/components/interactive.js","../node_modules/@esri/calcite-components/dist/components/label2.js"],"sourcesContent":["/*!\n * All material copyright ESRI, All Rights Reserved, unless otherwise specified.\n * See https://github.com/Esri/calcite-design-system/blob/main/LICENSE.md for details.\n * v1.5.1\n */\nimport { q as queryElementRoots, c as closestElementCrossShadowBoundary } from './dom.js';\nimport { h } from '@stencil/core/internal/client/index.js';\n\n(function(prototype) {\n  if (typeof prototype.requestSubmit == \"function\") return\n\n  prototype.requestSubmit = function(submitter) {\n    if (submitter) {\n      validateSubmitter(submitter, this);\n      submitter.click();\n    } else {\n      submitter = document.createElement(\"input\");\n      submitter.type = \"submit\";\n      submitter.hidden = true;\n      this.appendChild(submitter);\n      submitter.click();\n      this.removeChild(submitter);\n    }\n  };\n\n  function validateSubmitter(submitter, form) {\n    submitter instanceof HTMLElement || raise(TypeError, \"parameter 1 is not of type 'HTMLElement'\");\n    submitter.type == \"submit\" || raise(TypeError, \"The specified element is not a submit button\");\n    submitter.form == form || raise(DOMException, \"The specified element is not owned by this form element\", \"NotFoundError\");\n  }\n\n  function raise(errorConstructor, message, name) {\n    throw new errorConstructor(\"Failed to execute 'requestSubmit' on 'HTMLFormElement': \" + message + \".\", name)\n  }\n})(HTMLFormElement.prototype);\n\n/**\n * Exported for testing purposes.\n */\nconst hiddenFormInputSlotName = \"hidden-form-input\";\nfunction isCheckable(component) {\n  return \"checked\" in component;\n}\nconst onFormResetMap = new WeakMap();\nconst formComponentSet = new WeakSet();\n/**\n * This helps determine if our form component is part of a composite form-associated component.\n *\n * @param form\n * @param formComponentEl\n */\nfunction hasRegisteredFormComponentParent(form, formComponentEl) {\n  // if we have a parent component using the form ID attribute, we assume it is form-associated\n  const hasParentComponentWithFormIdSet = closestElementCrossShadowBoundary(formComponentEl.parentElement, \"[form]\");\n  if (hasParentComponentWithFormIdSet) {\n    return true;\n  }\n  // we use events as a way to test for nested form-associated components across shadow bounds\n  const formComponentRegisterEventName = \"calciteInternalFormComponentRegister\";\n  let hasRegisteredFormComponentParent = false;\n  form.addEventListener(formComponentRegisterEventName, (event) => {\n    hasRegisteredFormComponentParent = event\n      .composedPath()\n      .some((element) => formComponentSet.has(element));\n    event.stopPropagation();\n  }, { once: true });\n  formComponentEl.dispatchEvent(new CustomEvent(formComponentRegisterEventName, {\n    bubbles: true,\n    composed: true,\n  }));\n  return hasRegisteredFormComponentParent;\n}\n/**\n * Helper to submit a form.\n *\n * @param component\n * @returns true if its associated form was submitted, false otherwise.\n */\nfunction submitForm(component) {\n  const { formEl } = component;\n  if (!formEl) {\n    return false;\n  }\n  formEl.requestSubmit();\n  return true;\n}\n/**\n * Helper to reset a form.\n *\n * @param component\n */\nfunction resetForm(component) {\n  component.formEl?.reset();\n}\n/**\n * Helper to set up form interactions on connectedCallback.\n *\n * @param component\n */\nfunction connectForm(component) {\n  const { el, value } = component;\n  const associatedForm = findAssociatedForm(component);\n  if (!associatedForm || hasRegisteredFormComponentParent(associatedForm, el)) {\n    return;\n  }\n  component.formEl = associatedForm;\n  component.defaultValue = value;\n  if (isCheckable(component)) {\n    component.defaultChecked = component.checked;\n  }\n  const boundOnFormReset = (component.onFormReset || onFormReset).bind(component);\n  associatedForm.addEventListener(\"reset\", boundOnFormReset);\n  onFormResetMap.set(component.el, boundOnFormReset);\n  formComponentSet.add(el);\n}\n/**\n * Utility method to find a form-component's associated form element.\n *\n * @param component\n */\nfunction findAssociatedForm(component) {\n  const { el, form } = component;\n  return form\n    ? queryElementRoots(el, { id: form })\n    : closestElementCrossShadowBoundary(el, \"form\");\n}\nfunction onFormReset() {\n  if (isCheckable(this)) {\n    this.checked = this.defaultChecked;\n    return;\n  }\n  this.value = this.defaultValue;\n}\n/**\n * Helper to tear down form interactions on disconnectedCallback.\n *\n * @param component\n */\nfunction disconnectForm(component) {\n  const { el, formEl } = component;\n  if (!formEl) {\n    return;\n  }\n  const boundOnFormReset = onFormResetMap.get(el);\n  formEl.removeEventListener(\"reset\", boundOnFormReset);\n  onFormResetMap.delete(el);\n  component.formEl = null;\n  formComponentSet.delete(el);\n}\n/**\n * Helper for setting the default value on initialization after connectedCallback.\n *\n * Note that this is only needed if the default value cannot be determined on connectedCallback.\n *\n * @param component\n * @param value\n */\nfunction afterConnectDefaultValueSet(component, value) {\n  component.defaultValue = value;\n}\nconst hiddenInputChangeHandler = (event) => {\n  event.target.dispatchEvent(new CustomEvent(\"calciteInternalHiddenInputChange\", { bubbles: true }));\n};\nconst removeHiddenInputChangeEventListener = (input) => input.removeEventListener(\"change\", hiddenInputChangeHandler);\n/**\n * Helper for maintaining a form-associated's hidden input in sync with the component.\n *\n * Based on Ionic's approach: https://github.com/ionic-team/ionic-framework/blob/e4bf052794af9aac07f887013b9250d2a045eba3/core/src/utils/helpers.ts#L198\n *\n * @param component\n */\nfunction syncHiddenFormInput(component) {\n  const { el, formEl, name, value } = component;\n  const { ownerDocument } = el;\n  const inputs = el.querySelectorAll(`input[slot=\"${hiddenFormInputSlotName}\"]`);\n  if (!formEl || !name) {\n    inputs.forEach((input) => {\n      removeHiddenInputChangeEventListener(input);\n      input.remove();\n    });\n    return;\n  }\n  const values = Array.isArray(value) ? value : [value];\n  const extra = [];\n  const seen = new Set();\n  inputs.forEach((input) => {\n    const valueMatch = values.find((val) => \n    /* intentional non-strict equality check */\n    val == input.value);\n    if (valueMatch != null) {\n      seen.add(valueMatch);\n      defaultSyncHiddenFormInput(component, input, valueMatch);\n    }\n    else {\n      extra.push(input);\n    }\n  });\n  let docFrag;\n  values.forEach((value) => {\n    if (seen.has(value)) {\n      return;\n    }\n    let input = extra.pop();\n    if (!input) {\n      input = ownerDocument.createElement(\"input\");\n      input.slot = hiddenFormInputSlotName;\n    }\n    if (!docFrag) {\n      docFrag = ownerDocument.createDocumentFragment();\n    }\n    docFrag.append(input);\n    // emits when hidden input is autofilled\n    input.addEventListener(\"change\", hiddenInputChangeHandler);\n    defaultSyncHiddenFormInput(component, input, value);\n  });\n  if (docFrag) {\n    el.append(docFrag);\n  }\n  extra.forEach((input) => {\n    removeHiddenInputChangeEventListener(input);\n    input.remove();\n  });\n}\nfunction defaultSyncHiddenFormInput(component, input, value) {\n  const { defaultValue, disabled, form, name, required } = component;\n  // keep in sync to prevent losing reset value\n  input.defaultValue = defaultValue;\n  input.disabled = disabled;\n  input.name = name;\n  input.required = required;\n  input.tabIndex = -1;\n  // we set the attr as the prop is read-only\n  if (form) {\n    input.setAttribute(\"form\", form);\n  }\n  else {\n    input.removeAttribute(\"form\");\n  }\n  if (isCheckable(component)) {\n    input.checked = component.checked;\n    // keep in sync to prevent losing reset value\n    input.defaultChecked = component.defaultChecked;\n    // heuristic to support default/on mode from https://html.spec.whatwg.org/multipage/input.html#dom-input-value-default-on\n    input.value = component.checked ? value || \"on\" : \"\";\n  }\n  else {\n    input.value = value || \"\";\n  }\n  component.syncHiddenFormInput?.(input);\n}\n/**\n * Helper to render the slot for form-associated component's hidden input.\n *\n * If the component has a default slot, this must be placed at the bottom of the component's root container to ensure it is the last child.\n *\n * render(): VNode {\n *   <Host>\n *     <div class={CSS.container}>\n *     // ...\n *     <HiddenFormInputSlot component={this} />\n *     </div>\n *   </Host>\n * }\n *\n * Note that the hidden-form-input Sass mixin must be added to the component's style to apply specific styles.\n *\n * @param root0\n * @param root0.component\n */\nconst HiddenFormInputSlot = ({ component, }) => {\n  syncHiddenFormInput(component);\n  return h(\"slot\", { name: hiddenFormInputSlotName });\n};\n\nexport { HiddenFormInputSlot as H, afterConnectDefaultValueSet as a, connectForm as c, disconnectForm as d, findAssociatedForm as f, resetForm as r, submitForm as s };\n","/*!\n * All material copyright ESRI, All Rights Reserved, unless otherwise specified.\n * See https://github.com/Esri/calcite-design-system/blob/main/LICENSE.md for details.\n * v1.5.1\n */\nimport { Build } from '@stencil/core/internal/client/index.js';\n\nfunction getUserAgentData() {\n  return navigator.userAgentData;\n}\nfunction getUserAgentString() {\n  if (!Build.isBrowser) {\n    return \"\";\n  }\n  const uaData = getUserAgentData();\n  return uaData?.brands\n    ? uaData.brands.map(({ brand, version }) => `${brand}/${version}`).join(\" \")\n    : navigator.userAgent;\n}\n\n// ⚠️ browser-sniffing is not a best practice and should be avoided ⚠️\nconst isFirefox = /firefox/i.test(getUserAgentString());\nconst interactiveElementToParent = isFirefox\n  ? new WeakMap()\n  : null;\nfunction interceptedClick() {\n  const { disabled } = this;\n  if (!disabled) {\n    HTMLElement.prototype.click.call(this);\n  }\n}\nfunction onPointerDown(event) {\n  const interactiveElement = event.target;\n  if (isFirefox && !interactiveElementToParent.get(interactiveElement)) {\n    return;\n  }\n  const { disabled } = interactiveElement;\n  if (disabled) {\n    // prevent click from moving focus on host\n    event.preventDefault();\n  }\n}\nconst nonBubblingWhenDisabledMouseEvents = [\"mousedown\", \"mouseup\", \"click\"];\nfunction onNonBubblingWhenDisabledMouseEvent(event) {\n  if (isFirefox && !interactiveElementToParent.get(event.target)) {\n    return;\n  }\n  const { disabled } = event.target;\n  // prevent disallowed mouse events from being emitted on the disabled host (per https://github.com/whatwg/html/issues/5886)\n  //⚠ we generally avoid stopping propagation of events, but this is needed to adhere to the intended spec changes above ⚠\n  if (disabled) {\n    event.stopImmediatePropagation();\n    event.preventDefault();\n  }\n}\nconst captureOnlyOptions = { capture: true };\n/**\n * This helper updates the host element to prevent keyboard interaction on its subtree and sets the appropriate aria attribute for accessibility.\n *\n * This should be used in the `componentDidRender` lifecycle hook.\n *\n * **Notes**\n *\n * this util is not needed for simple components whose root element or elements are an interactive component (custom element or native control). For those cases, set the `disabled` props on the root components instead.\n * technically, users can override `tabindex` and restore keyboard navigation, but this will be considered user error\n *\n * @param component\n * @param hostIsTabbable\n */\nfunction updateHostInteraction(component, hostIsTabbable = false) {\n  if (component.disabled) {\n    component.el.setAttribute(\"tabindex\", \"-1\");\n    component.el.setAttribute(\"aria-disabled\", \"true\");\n    if (component.el.contains(document.activeElement)) {\n      document.activeElement.blur();\n    }\n    blockInteraction(component);\n    return;\n  }\n  restoreInteraction(component);\n  if (typeof hostIsTabbable === \"function\") {\n    component.el.setAttribute(\"tabindex\", hostIsTabbable.call(component) ? \"0\" : \"-1\");\n  }\n  else if (hostIsTabbable === true) {\n    component.el.setAttribute(\"tabindex\", \"0\");\n  }\n  else if (hostIsTabbable === false) {\n    component.el.removeAttribute(\"tabindex\");\n  }\n  else ;\n  component.el.removeAttribute(\"aria-disabled\");\n}\nfunction blockInteraction(component) {\n  component.el.click = interceptedClick;\n  addInteractionListeners(isFirefox ? getParentElement(component) : component.el);\n}\nfunction addInteractionListeners(element) {\n  if (!element) {\n    // this path is only applicable to Firefox\n    return;\n  }\n  element.addEventListener(\"pointerdown\", onPointerDown, captureOnlyOptions);\n  nonBubblingWhenDisabledMouseEvents.forEach((event) => element.addEventListener(event, onNonBubblingWhenDisabledMouseEvent, captureOnlyOptions));\n}\nfunction getParentElement(component) {\n  return interactiveElementToParent.get(component.el);\n}\nfunction restoreInteraction(component) {\n  delete component.el.click; // fallback on HTMLElement.prototype.click\n  removeInteractionListeners(isFirefox ? getParentElement(component) : component.el);\n}\nfunction removeInteractionListeners(element) {\n  if (!element) {\n    // this path is only applicable to Firefox\n    return;\n  }\n  element.removeEventListener(\"pointerdown\", onPointerDown, captureOnlyOptions);\n  nonBubblingWhenDisabledMouseEvents.forEach((event) => element.removeEventListener(event, onNonBubblingWhenDisabledMouseEvent, captureOnlyOptions));\n}\n/**\n * This utility helps disable components consistently in Firefox.\n *\n * It needs to be called in `connectedCallback` and is only needed for Firefox as it does not call capture event listeners before non-capture ones (see https://bugzilla.mozilla.org/show_bug.cgi?id=1731504).\n *\n * @param component\n */\nfunction connectInteractive(component) {\n  if (!component.disabled || !isFirefox) {\n    return;\n  }\n  const parent = component.el.parentElement || component.el; /* assume element is host if it has no parent when connected */\n  interactiveElementToParent.set(component.el, parent);\n  blockInteraction(component);\n}\n/**\n * This utility restores interactivity to disabled components consistently in Firefox.\n *\n * It needs to be called in `disconnectedCallback` and is only needed for Firefox as it does not call capture event listeners before non-capture ones (see https://bugzilla.mozilla.org/show_bug.cgi?id=1731504).\n *\n * @param component\n */\nfunction disconnectInteractive(component) {\n  if (!isFirefox) {\n    return;\n  }\n  // always remove on disconnect as render or connect will restore it\n  interactiveElementToParent.delete(component.el);\n  restoreInteraction(component);\n}\n\nexport { connectInteractive as c, disconnectInteractive as d, updateHostInteraction as u };\n","/*!\n * All material copyright ESRI, All Rights Reserved, unless otherwise specified.\n * See https://github.com/Esri/calcite-design-system/blob/main/LICENSE.md for details.\n * v1.5.1\n */\nimport { q as queryElementRoots, c as closestElementCrossShadowBoundary } from './dom.js';\n\n/**\n * Exported for testing purposes only\n *\n * @internal\n */\nconst labelClickEvent = \"calciteInternalLabelClick\";\nconst labelConnectedEvent = \"calciteInternalLabelConnected\";\nconst labelDisconnectedEvent = \"calciteInternaLabelDisconnected\";\nconst labelTagName = \"calcite-label\";\nconst onLabelClickMap = new WeakMap();\nconst onLabelConnectedMap = new WeakMap();\nconst onLabelDisconnectedMap = new WeakMap();\nconst unlabeledComponents = new Set();\nconst findLabelForComponent = (componentEl) => {\n  const { id } = componentEl;\n  const forLabel = id && queryElementRoots(componentEl, { selector: `${labelTagName}[for=\"${id}\"]` });\n  if (forLabel) {\n    return forLabel;\n  }\n  const parentLabel = closestElementCrossShadowBoundary(componentEl, labelTagName);\n  if (!parentLabel ||\n    // labelable components within other custom elements are not considered labelable\n    hasAncestorCustomElements(parentLabel, componentEl)) {\n    return null;\n  }\n  return parentLabel;\n};\nfunction hasAncestorCustomElements(label, componentEl) {\n  let traversedElements;\n  const customElementAncestorCheckEventType = \"custom-element-ancestor-check\";\n  const listener = (event) => {\n    event.stopImmediatePropagation();\n    const composedPath = event.composedPath();\n    traversedElements = composedPath.slice(composedPath.indexOf(componentEl), composedPath.indexOf(label));\n  };\n  label.addEventListener(customElementAncestorCheckEventType, listener, { once: true });\n  componentEl.dispatchEvent(new CustomEvent(customElementAncestorCheckEventType, { composed: true, bubbles: true }));\n  label.removeEventListener(customElementAncestorCheckEventType, listener);\n  const ancestorCustomElements = traversedElements\n    .filter((el) => el !== componentEl && el !== label)\n    .filter((el) => el.tagName?.includes(\"-\"));\n  return ancestorCustomElements.length > 0;\n}\n/**\n * Helper to set up label interactions on connectedCallback.\n *\n * @param component\n */\nfunction connectLabel(component) {\n  const labelEl = findLabelForComponent(component.el);\n  if (onLabelClickMap.has(labelEl) || (!labelEl && unlabeledComponents.has(component))) {\n    return;\n  }\n  const boundOnLabelDisconnected = onLabelDisconnected.bind(component);\n  if (labelEl) {\n    component.labelEl = labelEl;\n    const boundOnLabelClick = onLabelClick.bind(component);\n    onLabelClickMap.set(component.labelEl, boundOnLabelClick);\n    component.labelEl.addEventListener(labelClickEvent, boundOnLabelClick);\n    unlabeledComponents.delete(component);\n    document.removeEventListener(labelConnectedEvent, onLabelConnectedMap.get(component));\n    onLabelDisconnectedMap.set(component, boundOnLabelDisconnected);\n    document.addEventListener(labelDisconnectedEvent, boundOnLabelDisconnected);\n  }\n  else if (!unlabeledComponents.has(component)) {\n    boundOnLabelDisconnected();\n    document.removeEventListener(labelDisconnectedEvent, onLabelDisconnectedMap.get(component));\n  }\n}\n/**\n * Helper to tear down label interactions on disconnectedCallback on labelable components.\n *\n * @param component\n */\nfunction disconnectLabel(component) {\n  unlabeledComponents.delete(component);\n  document.removeEventListener(labelConnectedEvent, onLabelConnectedMap.get(component));\n  document.removeEventListener(labelDisconnectedEvent, onLabelDisconnectedMap.get(component));\n  onLabelConnectedMap.delete(component);\n  onLabelDisconnectedMap.delete(component);\n  if (!component.labelEl) {\n    return;\n  }\n  const boundOnLabelClick = onLabelClickMap.get(component.labelEl);\n  component.labelEl.removeEventListener(labelClickEvent, boundOnLabelClick);\n  onLabelClickMap.delete(component.labelEl);\n}\n/**\n * Helper to get the label text from a component.\n *\n * @param component\n */\nfunction getLabelText(component) {\n  return component.label || component.labelEl?.textContent?.trim() || \"\";\n}\nfunction onLabelClick(event) {\n  if (this.disabled) {\n    return;\n  }\n  const containedLabelableChildClicked = this.el.contains(event.detail.sourceEvent.target);\n  if (containedLabelableChildClicked) {\n    return;\n  }\n  this.onLabelClick(event);\n}\nfunction onLabelConnected() {\n  if (unlabeledComponents.has(this)) {\n    connectLabel(this);\n  }\n}\nfunction onLabelDisconnected() {\n  unlabeledComponents.add(this);\n  const boundOnLabelConnected = onLabelConnectedMap.get(this) || onLabelConnected.bind(this);\n  onLabelConnectedMap.set(this, boundOnLabelConnected);\n  document.addEventListener(labelConnectedEvent, boundOnLabelConnected);\n}\n\nexport { labelDisconnectedEvent as a, connectLabel as c, disconnectLabel as d, getLabelText as g, labelConnectedEvent as l };\n"],"names":["prototype","raise","errorConstructor","message","name","requestSubmit","submitter","form","HTMLElement","TypeError","type","DOMException","validateSubmitter","this","click","document","createElement","hidden","appendChild","removeChild","HTMLFormElement","hiddenFormInputSlotName","isCheckable","component","onFormResetMap","WeakMap","formComponentSet","WeakSet","submitForm","formEl","connectForm","el","value","associatedForm","queryElementRoots","id","closestElementCrossShadowBoundary","findAssociatedForm","formComponentEl","parentElement","formComponentRegisterEventName","hasRegisteredFormComponentParent","addEventListener","event","composedPath","some","element","has","stopPropagation","once","dispatchEvent","CustomEvent","bubbles","composed","defaultValue","defaultChecked","checked","boundOnFormReset","onFormReset","bind","set","add","disconnectForm","get","removeEventListener","delete","hiddenInputChangeHandler","target","removeHiddenInputChangeEventListener","input","defaultSyncHiddenFormInput","_component$syncHidden","disabled","required","tabIndex","setAttribute","removeAttribute","syncHiddenFormInput","call","HiddenFormInputSlot","_ref","ownerDocument","inputs","querySelectorAll","concat","docFrag","values","Array","isArray","extra","seen","Set","forEach","valueMatch","find","val","push","pop","slot","createDocumentFragment","append","remove","h","isFirefox","test","Build","isBrowser","uaData","navigator","userAgentData","brands","map","brand","version","join","userAgent","getUserAgentString","interactiveElementToParent","interceptedClick","onPointerDown","interactiveElement","preventDefault","nonBubblingWhenDisabledMouseEvents","onNonBubblingWhenDisabledMouseEvent","stopImmediatePropagation","captureOnlyOptions","capture","updateHostInteraction","hostIsTabbable","arguments","length","undefined","contains","activeElement","blur","blockInteraction","restoreInteraction","addInteractionListeners","getParentElement","removeInteractionListeners","connectInteractive","parent","disconnectInteractive","labelClickEvent","labelConnectedEvent","labelDisconnectedEvent","labelTagName","onLabelClickMap","onLabelConnectedMap","onLabelDisconnectedMap","unlabeledComponents","findLabelForComponent","componentEl","forLabel","selector","parentLabel","label","traversedElements","customElementAncestorCheckEventType","listener","slice","indexOf","ancestorCustomElements","filter","_el$tagName","tagName","includes","hasAncestorCustomElements","connectLabel","labelEl","boundOnLabelDisconnected","onLabelDisconnected","boundOnLabelClick","onLabelClick","disconnectLabel","getLabelText","_component$labelEl","textContent","trim","detail","sourceEvent","onLabelConnected","boundOnLabelConnected"],"sourceRoot":""}